node_string_id: "os_command_line_shell"
name: "Terminal"
description: "Terminals are not only for ðŸ›«"
software_dependencies:
  - name: python
    version: 3.11.4
content:
  - type: "paragraph"
    value: |
      # Learning Objectives

      In this lesson, we will learn more about a new (but actually oldschool ðŸŽ¸) way to interact with the computer
      through the terminal. These are the necessary skills for anyone who wants to learn Python and programming 
      in general:

      1. **Running Python Scripts from the Terminal:** Our code doesn't live in a vacuum, it works 
      with other programs, files and operating system. We need to understand the environment in which our
      program is running. 

      2. **Navigating and Managing Files and Directories:** This is a fundamental skill for any programmer and
      again relates to the environment we are in. Our program and (and we) need to be aware of our surroundings 
      (files and directories).

      3. **Basic Knowledge of the Operating System:** We'll cover just the basics of the operating system (OS), like
      how programs and files interact with each other and how OS manages all of that.


      command_line_shell/terminal_text_file_cat.png

  - type: "paragraph"
    card_group: "what_is_terminal"
    value: |
      # What is a terminal?

      We are used to interacting with the computer through the graphical user interface or **GUI**. We launch 
      programs just by clicking on icons, navigate through files and directories by clicking on them, and
      we can see the data in them by opening them with the appropriate program. For example, to view the contents 
      of the folder, we can open it with some built-in file manager (doesn't matter what OS you are using,
      you can definitely recognise what happens here):
  - type: "paragraph"
    hero_image: https://storage.googleapis.com/scula-public-assets/courses/python/command_line_shell/gui_folder.png
    card_group: "what_is_terminal"
    value: |
      But there is another way to interact with the computer, even more powerful ðŸ”‹ and flexible. Surprisingly,
      it's done with a simple text. You type in a command, and the computer executes it. And the **terminal** is
      just a program through which we can access the super mode:
  - type: "paragraph"
    hero_image: https://storage.googleapis.com/scula-public-assets/courses/python/command_line_shell/terminal_folder_empty.png
    card_group: "what_is_terminal"
    value: |
      It looks different on different operating systems but the idea is always the same. Usually we see the 
      **prompt** (symbol that indicates that the terminal is ready to accept the command, in our example 
      it's the dollar sign `$`) and the **cursor** (symbol that indicates where the next character will 
      appear, in our example it's a white rectangle).

  - type: "paragraph"
    card_group: "rules"
    value: |
      # Two simple rules of working with the terminal

      **First**, in terminal you are *always in some directory*. It's not like in the GUI where you can just open
      multiple windows and switch between them. In the terminal you are always in some directory and to change
      it you will need to use the command. 

      So here:
  - type: "paragraph"
    hero_image: https://storage.googleapis.com/scula-public-assets/courses/python/command_line_shell/terminal_folder_empty.png
    card_group: "rules"
    value: |
      we are actually in the same directory as in the GUI, but we can't see the contents of the directory 
      or the name of the directory. To see it we can use the **second rule** - we invoke programs by typing 
      their name and pressing **Enter**. 

      Let's look around and check in what directory we are in. We will use `pwd` command which stands for
      **print working directory**:
  - type: "paragraph"
    hero_image: https://storage.googleapis.com/scula-public-assets/courses/python/command_line_shell/terminal_folder_pwd.png
    card_group: "rules"
    value: |
      We can see a new text below our command, it's called the **output**. In our case, it's:
      ```
      /Users/nzavyalov/dev/temp/our_folder
      ```
      Which is the path to the current directory. Path represents the hierarchy of directories and files.
      Everything starts from the toop `/` directory, which is called the **root** directory. And then we
      have directories and files inside of it. And `our_folder` is actually nested several levels deep in 
      the hierarchy.

  - type: "paragraph"
    card_group: "commands_programs"
    value: |
      # Commands and Programs 

      Now that we know the basics, let's check what's inside our directory. We can use the `ls` command which
      stands for **list**. It will list all the files and directories in the current directory:
  - type: "paragraph"
    hero_image: https://storage.googleapis.com/scula-public-assets/courses/python/command_line_shell/terminal_folder_ls.png
    card_group: "commands_programs"
    value: |
      Which is the same as in the GUI. But what if we want to see the contents of the file? We can use the `cat`
      command which stands for **concatenate** but is usually used to print the contents of the file to the terminal:
  - type: "paragraph"
    hero_image: https://storage.googleapis.com/scula-public-assets/courses/python/command_line_shell/terminal_text_file_cat.png
    card_group: "commands_programs"
    value: |
      And we can see the contents of the file. But this time we didn't type only the name of the program, we also
      added the name of the file. And that's because `cat` is a program that accepts arguments. And the arguments
      are just additional information that we pass to the program. In our case, we passed the name of the file
      to the `cat` program. Spoiler: same will happen when we will try to launch our Python program.

  - type: "paragraph"
    value: |
      Create new python file through terminal 
      Launch it


      Let's explore how the terminal works through a comparison with the usual graphical user interface.

  - type: "hint"
    value: |
      Bonus: Terminal is actually just a program that allows us to interact with the shell which is another 
      program ðŸª† that does the actual communication with the operating system. There are many different shells,
      but we will use **bash** because it's one of the most popular shells and the default shell on most Linux
      distributions, Mac OS and can be installed on Windows too.

  - type: "paragraph"
    value: |
      # Operating Systems

      You can think of it as an orchestra conductor responsible for unison between all the different
      parts of the computer. Let's take a single program as an example, like your **web browser**. It has to
      perform multiple tasks:
      * It has to output and render web pages that you are visiting on your screen;
      * It has to respond to your input, like clicking on a link or typing in a search query;
      * It has to communicate with the internet to download web pages, images and other files;
      * It has to communicate with the computer's hardware to save downloaded files and your search history.
      All of that requires a lot of coordination between different parts. 

      And what's interesting is that web browsers, like any program, rely heavily on abstraction. It doesn't
      have to know how to communicate with the hardware or render the web pages. It just has to know
      how to communicate with the operating system. And the operating system will take care of the rest.

  - type: "paragraph"
    value: |
      # Terminal and Operating System

      Now we've established why we need the operating system. But how do we interact with it? Well,
      there are two ways. The first one is through the graphical user interface or **GUI**. That's what you
      are doing right now. You are using your mouse to click on the buttons and links, your
      keyboard to type in the search queries, and your screen to see the output. But there is
      another way to interact with the operating system, and that's through the **command line**. 
      It's a text-based interface allows us to type commands and execute them. And the program that 
      we use to interact
      with the operating system is called the **shell**.

      ## Command line and Shell

      What can we do with the shell? We can do pretty much everything we can with the graphical
      user interface. We can open programs; we can create files; we can delete files; we can move files around; we can install programs; we can uninstall programs. And the shell is a potent tool. It allows us
      to do things we can't do with the graphical user interface. For example, we can write scripts that
      automate some tasks. We can write programs that interact with the operating system. And we can do all of
      that without ever touching the mouse. And that's why the shell is so popular among programmers and system
      administrators.

      Now let's dive into some popular terms: how did they appear, and what do they mean?

      * The **terminal** is a device that gives you access to your computer's console. In the past 
      it was a physical device (before terminals were monitors with keyboards, they were teletypes) 
      and then its concept was transferred into software, like GNOME Terminal.

      * A **terminal emulator** is a program that we use these days to access the console, like GNOME Terminal
      for Linux, Terminal.app for Mac OS, Command Prompt, or PowerShell for Windows.

      * The **shell** is a program that runs on your computer and allows you to interact with the operating
      system. It's a command line interpreter that translates commands entered by the user and converts them
      into a language that is understood by the kernel (kernel is the core of the operating system). There are
      many different shells, like Bash, Zsh, Fish, Ksh. We will use Bash in this course because 
      it's one of the most popular shells and the default shell on most Linux distributions and Mac OS.
      We will also use Bash for Windows, but it's not the default shell. We will be using a program called
      Cygwin that allows us to run Bash on Windows.


      To sum up, the Operating System manages everything, and we need a way to interact with it. And we can
      do that through the graphical user interface or the shell. And the program that we use to
      interact with the Operating System is called the **shell**. We do it through the **command line** or
      **terminal**. And the **terminal** is a program that runs on your computer and allows you to interact
      with the **shell**.

  - type: "paragraph"
    card_group: "basic_cmds"
    value: |
      # Basic Commands

      Now let's talk about some basic commands we can use in the shell. As we said, we can navigate,
      manipulate files and directories, we can install programs, and can do all of that without ever touching
      the mouse. 


      Let's start with navigation. We can navigate the file system using the `cd` command. `cd` stands
      for change directory. And it allows us to change the current working directory. The current working
      directory is the one we are currently in. (Think of it as an open folder on your computer, 
      for example, you've opened the Downloads folder, and now you can see and click on all the files in that
      folder. That's the current working directory).
  - type: "hint"
    card_group: "basic_cmds"
    value: |
      For now we'll just list most popular commands but you will have the chance to practice them in the Codelab 
      at the end of the lesson.

  - type: "paragraph"
    card_group: "navigating"
    value: |
      ## Change directory command

       ```
       $ cd /home
       ```
       This command will change the current working directory to the `/home` directory. And the `/home` directory
       is a directory that contains all the user directories. So if we run the `ls` command, which stands for the list, 
       we will see all the user directories. And if we want to change the current working directory to the user 
       directory, we can run the `cd` command again. For example, let's change the current working directory to 
       the `student` directory.
       ```
       $ cd student
       ```
       And now, if we run the `ls` command, we will see all the files and directories in the `student` directory.
       And if we want to go back to the previous directory, we can use the `cd` command with the `..` argument.
       ```
       $ cd ..
       ```
  - type: "hint"
    card_group: "navigating"
    value: |
      The `.` and `..` are special directories. The `.` directory is the current directory, and the `..` directory
      is the parent directory. So if we run the `cd` command with the `..` argument, we will go back to the parent
      directory. And if we run the `cd` command with the `.` argument, we will stay in the current directory.

  - type: "paragraph"
    card_group: "navigating"
    value: |
      To check the current working directory, we can use the `pwd` command. `pwd` stands for print working directory.
      ```
      $ pwd
      ```

  - type: "paragraph"
    value: |
      ## Manipulating files and directories

      Now let's talk about manipulating files and directories. We can create files and directories using the `touch`
      and `mkdir` commands. `touch` command creates an empty file and `mkdir` command creates an empty directory.
      ```
      $ touch file.txt
      $ mkdir directory
      ```
      We can copy files and directories using the `cp` command. `cp` command copies files and directories from
      one location to another.
      ```
      $ cp file.txt directory/filecopy.txt
      ```
      Also, we can move files and directories using the `mv` command. `mv` command moves files and directories from
      one location to another.
      ```
      $ mv file.txt directory
      ```
      And we can delete files and directories using the `rm` and `rmdir` commands. `rm` command removes files and
      The `rmdir` command removes empty directories.
      ```
      $ rm file.txt
      $ rmdir directory
      ```
  - type: "paragraph"
    card_group: "codelab_fun"
    value: |
      ## Practice in the Lab
      Now let's practice in the lab. Click on the button below to create a new lab session.
  - type: "codelab"
    card_group: "codelab_fun"
    gcs_url: gs://scula-codelabs/codelabs_intro_python_commandline-af75b6c.tar.gz
    codelab_image: europe-docker.pkg.dev/amazemind/amazemind-services/codelab-intro-python:0.20
    codelab_guard_image: europe-docker.pkg.dev/amazemind/amazemind-services/codelab-guard-intro-python:0.14
